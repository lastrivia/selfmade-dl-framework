[
  {
    "name": "operator+",
    "args": "const tensor &b",
    "this": "a",
    "tensors": [
      "a",
      "b"
    ],
    "shape": "ewise",
    "ewise_args": [
      "a",
      "b"
    ],
    "fixed_dtype": false,
    "dtypes": [
      "fp32"
    ],
    "dtypes_unsupported": [
      "int32"
    ],
    "procedure": [
      {
        "kernel": "add_ewise",
        "args": [
          {
            "rule": "CONVERTED",
            "value": "result->shape_.size"
          },
          {
            "rule": "CONVERTED",
            "value": "result->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "a->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "b->data_"
          }
        ],
        "indent": 0,
        "raw": "add_ewise(size, result, a, b)"
      }
    ],
    "allow_grad": true,
    "internal_name": "add",
    "grad_args": "result, a, b"
  },
  {
    "name": "operator-",
    "args": "const tensor &b",
    "this": "a",
    "tensors": [
      "a",
      "b"
    ],
    "shape": "ewise",
    "ewise_args": [
      "a",
      "b"
    ],
    "fixed_dtype": false,
    "dtypes": [
      "fp32"
    ],
    "dtypes_unsupported": [
      "int32"
    ],
    "procedure": [
      {
        "kernel": "sub_ewise",
        "args": [
          {
            "rule": "CONVERTED",
            "value": "result->shape_.size"
          },
          {
            "rule": "CONVERTED",
            "value": "result->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "a->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "b->data_"
          }
        ],
        "indent": 0,
        "raw": "sub_ewise(size, result, a, b)"
      }
    ],
    "allow_grad": true,
    "internal_name": "sub",
    "grad_args": "result, a, b"
  },
  {
    "name": "operator*",
    "args": "const tensor &b",
    "this": "a",
    "tensors": [
      "a",
      "b"
    ],
    "shape": "ewise",
    "ewise_args": [
      "a",
      "b"
    ],
    "fixed_dtype": false,
    "dtypes": [
      "fp32"
    ],
    "dtypes_unsupported": [
      "int32"
    ],
    "procedure": [
      {
        "kernel": "mul_ewise",
        "args": [
          {
            "rule": "CONVERTED",
            "value": "result->shape_.size"
          },
          {
            "rule": "CONVERTED",
            "value": "result->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "a->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "b->data_"
          }
        ],
        "indent": 0,
        "raw": "mul_ewise(size, result, a, b)"
      }
    ],
    "allow_grad": true,
    "internal_name": "mul",
    "grad_args": "result, a, b"
  },
  {
    "name": "operator/",
    "args": "const tensor &b",
    "this": "a",
    "tensors": [
      "a",
      "b"
    ],
    "shape": "ewise",
    "ewise_args": [
      "a",
      "b"
    ],
    "fixed_dtype": false,
    "dtypes": [
      "fp32"
    ],
    "dtypes_unsupported": [
      "int32"
    ],
    "procedure": [
      {
        "kernel": "div_ewise",
        "args": [
          {
            "rule": "CONVERTED",
            "value": "result->shape_.size"
          },
          {
            "rule": "CONVERTED",
            "value": "result->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "a->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "b->data_"
          }
        ],
        "indent": 0,
        "raw": "div_ewise(size, result, a, b)"
      }
    ],
    "allow_grad": true,
    "internal_name": "div",
    "grad_args": "result, a, b"
  },
  {
    "name": "square",
    "args": "const tensor &t",
    "tensors": [
      "t"
    ],
    "shape": "identity",
    "fixed_dtype": false,
    "dtypes": [
      "fp32"
    ],
    "dtypes_unsupported": [
      "int32"
    ],
    "procedure": [
      {
        "kernel": "square",
        "args": [
          {
            "rule": "CONVERTED",
            "value": "result->shape_.size"
          },
          {
            "rule": "CONVERTED",
            "value": "result->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "t->data_"
          }
        ],
        "indent": 0,
        "raw": "square(size, result, t)"
      }
    ],
    "allow_grad": true,
    "internal_name": "square",
    "grad_args": "result, t"
  },
  {
    "name": "sqrt",
    "args": "const tensor &t",
    "tensors": [
      "t"
    ],
    "shape": "identity",
    "fixed_dtype": false,
    "dtypes": [
      "fp32"
    ],
    "dtypes_unsupported": [
      "int32"
    ],
    "procedure": [
      {
        "kernel": "sqrt",
        "args": [
          {
            "rule": "CONVERTED",
            "value": "result->shape_.size"
          },
          {
            "rule": "CONVERTED",
            "value": "result->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "t->data_"
          }
        ],
        "indent": 0,
        "raw": "sqrt(size, result, t)"
      }
    ],
    "allow_grad": true,
    "internal_name": "sqrt",
    "grad_args": "result, t"
  },
  {
    "name": "relu",
    "args": "const tensor &t",
    "tensors": [
      "t"
    ],
    "shape": "identity",
    "fixed_dtype": false,
    "dtypes": [
      "fp32"
    ],
    "dtypes_unsupported": [
      "int32"
    ],
    "procedure": [
      {
        "kernel": "relu",
        "args": [
          {
            "rule": "CONVERTED",
            "value": "result->shape_.size"
          },
          {
            "rule": "CONVERTED",
            "value": "result->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "t->data_"
          }
        ],
        "indent": 0,
        "raw": "relu(size, result, t)"
      }
    ],
    "allow_grad": true,
    "internal_name": "relu",
    "grad_args": "result, t"
  },
  {
    "name": "operator+",
    "args": "float scalar",
    "this": "t",
    "tensors": [
      "t"
    ],
    "shape": "identity",
    "fixed_dtype": "fp32",
    "procedure": [
      {
        "kernel": "add_scalar",
        "args": [
          {
            "rule": "CONVERTED",
            "value": "result->shape_.size"
          },
          {
            "rule": "CONVERTED",
            "value": "result->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "t->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "scalar"
          }
        ],
        "indent": 0,
        "raw": "add_scalar(size, result, t, scalar)"
      }
    ],
    "allow_grad": true,
    "internal_name": "add_scalar",
    "grad_args": "result, t, scalar"
  },
  {
    "name": "operator-",
    "args": "float scalar",
    "this": "t",
    "tensors": [
      "t"
    ],
    "shape": "identity",
    "fixed_dtype": "fp32",
    "procedure": [
      {
        "kernel": "add_scalar",
        "args": [
          {
            "rule": "CONVERTED",
            "value": "result->shape_.size"
          },
          {
            "rule": "CONVERTED",
            "value": "result->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "t->data_"
          },
          {
            "rule": "neg",
            "children": [
              {
                "rule": "CONVERTED",
                "value": "scalar"
              }
            ]
          }
        ],
        "indent": 0,
        "raw": "add_scalar(size, result, t, -scalar)"
      }
    ],
    "allow_grad": true,
    "internal_name": "sub_scalar",
    "grad_args": "result, t, scalar"
  },
  {
    "name": "operator*",
    "args": "float scalar",
    "this": "t",
    "tensors": [
      "t"
    ],
    "shape": "identity",
    "fixed_dtype": "fp32",
    "procedure": [
      {
        "kernel": "mul_scalar",
        "args": [
          {
            "rule": "CONVERTED",
            "value": "result->shape_.size"
          },
          {
            "rule": "CONVERTED",
            "value": "result->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "t->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "scalar"
          }
        ],
        "indent": 0,
        "raw": "mul_scalar(size, result, t, scalar)"
      }
    ],
    "allow_grad": true,
    "internal_name": "mul_scalar",
    "grad_args": "result, t, scalar"
  },
  {
    "name": "operator/",
    "args": "float scalar",
    "this": "t",
    "tensors": [
      "t"
    ],
    "shape": "identity",
    "fixed_dtype": "fp32",
    "procedure": [
      {
        "kernel": "mul_scalar",
        "args": [
          {
            "rule": "CONVERTED",
            "value": "result->shape_.size"
          },
          {
            "rule": "CONVERTED",
            "value": "result->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "t->data_"
          },
          {
            "rule": "div",
            "children": [
              {
                "rule": "auto",
                "children": [
                  {
                    "rule": "NUMBER",
                    "value": "1"
                  }
                ]
              },
              {
                "rule": "CONVERTED",
                "value": "scalar"
              }
            ]
          }
        ],
        "indent": 0,
        "raw": "mul_scalar(size, result, t, auto(1) / scalar)"
      }
    ],
    "allow_grad": true,
    "internal_name": "div_scalar",
    "grad_args": "result, t, scalar"
  },
  {
    "name": "pow",
    "args": "const tensor &t, float scalar",
    "tensors": [
      "t"
    ],
    "shape": "identity",
    "fixed_dtype": "fp32",
    "procedure": [
      {
        "kernel": "pow",
        "args": [
          {
            "rule": "CONVERTED",
            "value": "result->shape_.size"
          },
          {
            "rule": "CONVERTED",
            "value": "result->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "t->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "scalar"
          }
        ],
        "indent": 0,
        "raw": "pow(size, result, t, scalar)"
      }
    ],
    "allow_grad": true,
    "internal_name": "pow",
    "grad_args": "result, t, scalar"
  },
  {
    "name": "add_broadcast",
    "args": "const tensor &a, const tensor &b",
    "tensors": [
      "a",
      "b"
    ],
    "shape": "broadcast",
    "broadcast_args": [
      "a",
      "b"
    ],
    "fixed_dtype": false,
    "dtypes": [
      "fp32"
    ],
    "dtypes_unsupported": [
      "int32"
    ],
    "procedure": [
      {
        "kernel": "add_broadcast",
        "args": [
          {
            "rule": "CONVERTED",
            "value": "result->shape_.size"
          },
          {
            "rule": "CONVERTED",
            "value": "result->shape_.ndim"
          },
          {
            "rule": "CONVERTED",
            "value": "result->shape_.lengths"
          },
          {
            "rule": "CONVERTED",
            "value": "a_mask"
          },
          {
            "rule": "CONVERTED",
            "value": "b_mask"
          },
          {
            "rule": "CONVERTED",
            "value": "result->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "a->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "b->data_"
          }
        ],
        "indent": 0,
        "raw": "add_broadcast(size, ndim, lengths, a.mask, b.mask, result, a, b)"
      }
    ],
    "allow_grad": true,
    "internal_name": "add_broadcast",
    "grad_args": "result, a, b"
  },
  {
    "name": "sum",
    "args": "const tensor &t",
    "tensors": [
      "t"
    ],
    "shape": "reduction",
    "reduction_source": "t",
    "reduction_dims": "dims",
    "fixed_dtype": false,
    "dtypes": [
      "fp32"
    ],
    "dtypes_unsupported": [
      "int32"
    ],
    "procedure": [
      {
        "kernel": "sum",
        "args": [
          {
            "rule": "CONVERTED",
            "value": "t->shape_.size"
          },
          {
            "rule": "CONVERTED",
            "value": "result->shape_.ndim"
          },
          {
            "rule": "CONVERTED",
            "value": "t->shape_.lengths"
          },
          {
            "rule": "CONVERTED",
            "value": "mask"
          },
          {
            "rule": "CONVERTED",
            "value": "result->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "t->data_"
          }
        ],
        "indent": 0,
        "raw": "sum(t.size, ndim, t.lengths, $mask, result, t)"
      }
    ],
    "allow_grad": false
  },
  {
    "name": "maxpool",
    "args": "const tensor &t, size_t h_stride, size_t w_stride",
    "tensors": [
      "t"
    ],
    "shape": "pooling",
    "pooling_source": "t",
    "pooling_strides": {
      "1": "h_stride",
      "0": "w_stride"
    },
    "fixed_dtype": false,
    "dtypes": [
      "fp32"
    ],
    "dtypes_unsupported": [
      "int32"
    ],
    "procedure": [
      {
        "kernel": "maxpool",
        "args": [
          {
            "rule": "div",
            "children": [
              {
                "rule": "div",
                "children": [
                  {
                    "rule": "CONVERTED",
                    "value": "t->shape_.size"
                  },
                  {
                    "rule": "CONVERTED",
                    "value": "t->shape_.lengths[1]"
                  }
                ]
              },
              {
                "rule": "CONVERTED",
                "value": "t->shape_.lengths[0]"
              }
            ]
          },
          {
            "rule": "CONVERTED",
            "value": "t->shape_.lengths[1]"
          },
          {
            "rule": "CONVERTED",
            "value": "t->shape_.lengths[0]"
          },
          {
            "rule": "CONVERTED",
            "value": "h_stride"
          },
          {
            "rule": "CONVERTED",
            "value": "w_stride"
          },
          {
            "rule": "CONVERTED",
            "value": "result->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "mask"
          },
          {
            "rule": "CONVERTED",
            "value": "t->data_"
          }
        ],
        "indent": 0,
        "raw": "maxpool(t.size / t.lengths[1] / t.lengths[0], t.lengths[1], t.lengths[0], h_stride, w_stride, result, $mask, t)"
      }
    ],
    "allow_grad": true,
    "internal_name": "maxpool",
    "grad_args": "result, t, h_stride, w_stride"
  },
  {
    "name": "matmul",
    "args": "const tensor &a, const tensor &b",
    "tensors": [
      "a",
      "b"
    ],
    "shape": "matmul",
    "matmul_first": "a",
    "matmul_second": "b",
    "fixed_dtype": false,
    "dtypes": [
      "fp32"
    ],
    "dtypes_unsupported": [
      "int32"
    ],
    "procedure": [
      {
        "kernel": "gemm",
        "args": [
          {
            "rule": "CONVERTED",
            "value": "matmul_m"
          },
          {
            "rule": "CONVERTED",
            "value": "matmul_k"
          },
          {
            "rule": "CONVERTED",
            "value": "matmul_n"
          },
          {
            "rule": "CONVERTED",
            "value": "result->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "a->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "b->data_"
          }
        ],
        "template_args": [
          {
            "rule": "CONVERTED",
            "value": "transpose_a"
          },
          {
            "rule": "CONVERTED",
            "value": "transpose_b"
          }
        ],
        "indent": 0,
        "raw": "gemm<a.transpose, b.transpose>($m, $k, $n, result, a, b)"
      }
    ],
    "allow_grad": true,
    "internal_name": "matmul",
    "grad_args": "result, a, b"
  },
  {
    "name": "conv",
    "args": "const tensor &input, const tensor &kernel, const tensor &bias, size_t h_padding, size_t w_padding",
    "tensors": [
      "input",
      "kernel",
      "bias"
    ],
    "shape": "conv",
    "conv_input": "input",
    "conv_kernel": "kernel",
    "conv_bias": "bias",
    "conv_h_padding": "h_padding",
    "conv_w_padding": "w_padding",
    "fixed_dtype": false,
    "dtypes": [
      "fp32"
    ],
    "dtypes_unsupported": [
      "int32"
    ],
    "procedure": [
      {
        "kernel": "conv",
        "args": [
          {
            "rule": "CONVERTED",
            "value": "conv_n"
          },
          {
            "rule": "CONVERTED",
            "value": "conv_ci"
          },
          {
            "rule": "CONVERTED",
            "value": "conv_co"
          },
          {
            "rule": "CONVERTED",
            "value": "input->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "conv_input->shape_.lengths[1]"
          },
          {
            "rule": "CONVERTED",
            "value": "conv_input->shape_.lengths[0]"
          },
          {
            "rule": "CONVERTED",
            "value": "kernel->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "conv_kernel->shape_.lengths[1]"
          },
          {
            "rule": "CONVERTED",
            "value": "conv_kernel->shape_.lengths[0]"
          },
          {
            "rule": "CONVERTED",
            "value": "h_padding"
          },
          {
            "rule": "CONVERTED",
            "value": "w_padding"
          },
          {
            "rule": "CONVERTED",
            "value": "bias->data_"
          },
          {
            "rule": "CONVERTED",
            "value": "result->data_"
          }
        ],
        "indent": 0,
        "raw": "conv($n, $ci, $co, input, $hi, $wi, kernel, $hk, $wk, h_padding, w_padding, bias, result)"
      }
    ],
    "allow_grad": true,
    "internal_name": "conv",
    "grad_args": "result, input, kernel, bias, h_padding, w_padding"
  }
]